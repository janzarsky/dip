# Diploma thesis

## Resources

### Repos

* [original RoadRunner](https://github.com/stephenfreund/RoadRunner)
* [roadrunnerX](https://pajda.fit.vutbr.cz/jct/roadrunnerX)
* [rrcontractvalidator](https://pajda.fit.vutbr.cz/jct/rrcontractvalidator)

### Papers

* Dynamické analyzátory pro platformu SearchBestie (2017)
* Fine-grain Noise-injection Heuristics for SearchBestie Infrastructure (2017)
* [Verifying Concurrent Programs using Contracts](http://www.fit.vutbr.cz/~vojnar/Publications/icst17-contracts.pdf)
  (2017)
  * basic contract:
    Σ_M: set of all public names (API)
    R: contract, regex over Σ_M
    ρ: clause, ρ ∈ R
  * contract with parameters: added meta-variables (X, Y, ...) and free
    meta-variable (_)
  * contract with spoilers:
    R: set of target clauses
    ρ: target clause, ρ ∈ R
    S: set of spoilers
    σ: spoiler, σ ∈ S, regex over Σ_M
    Σ_R: methods used in targets, Σ_R ⊂ Σ_M
    Σ_S: methods used in spoilers, Σ_S ⊂ Σ_M
    C: contract, C ⊆ R×S
  * contract violation: r.start, s.start, s.end, r.end
  * dynamis analysis:
    * threads T, targets R, spoilers S, contracts C, locks L
    * event types: thread entering/exiting method, thread acquiring/releasing
      lock, thread forking/joining another thread
    E_t: set of events that can be generated by a thread, t ∈ T
    E: E = ∪_{t ∈ T} E_t
    τ: trace, τ = e_1 ... e_n ∈ E⁺
    start(t), end(t): first/last event generated by a thread
    * trace subsequence is an instance of a target iff
      1. well paired enter/exit events
      2. enter events matches the contract target regex
      3. no other interleaved events from the target alphabet
    * ≺\_hb: happens-before relation over events in a trace, e\_j ≺\_hb e\_k
      holds whenever j < k and one of the following holds
      1. same thread (program order)
      2. acquire/release the same lock
      3. fork/join
    * contract violation: r may start before s and end after s
      start(s) ⊀_hb start(r) ∧ end(r) ⊀_hb end(s)
    * trace window: υ
      υ → e: remove event e from trace window υ
      υ → r: remove all events from r provided they do not belong to another
      tracked instance of a target or spoiler
      υ → s: remove all events from s provided...
    * discarding spoilers:
      * lemma 1: if start(s\_1) ≺\_hb start(s\_2) then s\_1 can be discarded
      * lemma 2: for each thread that started before the end of the window, we
        can keep only the last spoiler instance
    * discarding targets:
      * TODO
    * vector clocks:
      * one logical clock per thread
      * each thread has a local copy of global clock array
      * vector clock for threads: incremented on lock release or fork
      * vector clock for locks: incremented on operations that impose a
        happens-before relation
* [Verifying Concurrent Programs using Contracts - Technical Report](http://www.fit.vutbr.cz/~vojnar/Publications/tr-contracts-16.pdf)
  * proofs for lemmas in dynamic analysis in ^^^
* [Dynamic validation of contracts in concurrent code](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.715.114&rep=rep1&type=pdf)
  (2015)
  * dynamic analysis instead of static
  * contract detection: finite automata for each thread and observed contract
    sequence
  * checking atomicity: lockset-based, at least one lock must be held during the
    contract sequence
  * false positives and false negatives
* [Preventing atomicity violations with contracts](https://docentes.fct.unl.pt/joao-lourenco/files/1505.02951v1-dsousa.pdf)
  (2015)
  * contract definition
  * analysis:
    1. entry methods of threads
    2. detect atomically executed methods
    3. extract program behavior with respect to the module under analysis
    4. verify thatt the module is used according to the contract
  * program's thread behavior grammar
  * possible mistake in 1st example: missing G -\> H
  * contract verification algorithm
  * adding points-to information (modified grammar)
  * contracts with parameters
* [ANaConDA: A Framework for Analysing Multithreaded C/C++ Programs on the Binary Level](http://dx.doi.org/10.1007/978-3-642-35632-2_5)
  (2012)
* The RoadRunner Dynamic Analysis Framework for Concurrent Programs (2010)
  * introduction:
    * for writing dynamic analysis
    * event handlers for different kind of events
    * composition: different tools can be chained
    * each analysis is a filter over event stream
    * diagnostic tools: print, time, count, record
    * comparation of dynamic analyses
  * API:
    * thread and lock shadows
    * variable shadows
    * events
    * tool composition
  * implementation details: TODO
  * optimizations: TODO
* FastTrack: efficient and precise dynamic race detection (2009)
* C. Hurlin. Specifying and checking protocols of multithreaded classes. (2009)
* Y. Cheon and A. Perumandla. Specifying and checking method call sequences of
  java programs. (2007)
* Control flow analysis (2003)
  * control flow graph definition
* [Eraser: A Dynamic Data Race Detector for Multithreaded Programs](http://cseweb.ucsd.edu/~savage/papers/Tocs97.pdf)
* [Applying “design by contract”](http://se.ethz.ch/~meyer/publications/computer/contract.pdf)
  (1992)
  * move away from defensive programming
  * contract = precondition, postcondition, invariant
  * no hidden clauses
  * who should check - client vs. supplier
  * invariants: hold for all observable states
  * inheritance: precondition must be equal or weaker, postcondition equal or
    stronger
  * dynamic binding
  * exception handling
  * [Wikipedia](https://en.wikipedia.org/wiki/Design_by_contract)

### Videos

* [Java bytecode](https://www.youtube.com/watch?v=e2zmmkc5xI0)

## RoadRunner

* tools:
         A : AtomizerTool                      tools.atomizer
        BE : EraserWithBarriersTool            tools.barrier_eraser
         C : CountTool                         rr.simple
    FPTest : FastPathTestTool                  rr.simple
       FT2 : FastTrackTool                     tools.fasttrack
      FT2L : FastTrackTool                     tools.fasttrack_long
        HB : HappensBeforeTool                 tools.hb
       LOG : ReplayLogTool                     rr.simple
        LS : LockSetTool                       tools.eraser
         N : EmptyTool                         rr.simple
         P : PrintTool                         rr.simple
        PL : ProtectingLockTool                tools.eraser
        RS : ReadSharedTool                    tools.eraser
         S : SyncTool                          rr.simple
    SFPTool : SpecializedFastPathTestTool      rr.simple
         T : TimerTool                         rr.simple
        TL : ThreadLocalTool                   rr.simple
* CountTool: Access, VolatileAccess, Array Access, Acquire, Release, Enter,
  Exit, Wait, Notify, Sleep, Join, Start, Guard State
* PrintTool: example
    [main: New Thread main with tid=0.]
    @  main[tid = 0] started .
    @  Enter(0,test/Test.main([Ljava/lang/String;)V) from null
    [main: New Thread Thread-0 with tid=1.]
    @  Thread-0[tid = 1] started by main[tid = 0].
    @   Start(0,1)
    @  Enter(1,test/Test.run()V) from null
    @   Enter(1,test/Test.inc()V) from null
    @    Rd(1,null.test/Test.y_I)  Final  Test.java:48:0
    @   Exit(1,test/Test.inc()V)
    @   Enter(1,test/Test.inc()V) from null
    @   Exit(1,test/Test.inc()V)
    @   Start(0,1)
    [main: New Thread Thread-1 with tid=2.]
    @  Thread-1[tid = 2] started by main[tid = 0].
    @   Start(0,2)
    @   Enter(1,test/Test.inc()V) from null
    @   Exit(1,test/Test.inc()V)
    @   Enter(1,test/Test.inc()V) from null
    @   Exit(1,test/Test.inc()V)
    ...
* TimerTool: timers for each event type
* SyncTool: all events are `synchronized`
* EmptyTool: only for performance tests
* ReplayLogTool: writes events to a log
* ThreadLocalTool: filters out thread local accesses
* LastTool: last tool in any chain, does nothing
* FastPathTestTool: ???, SpecializedFastPathTestTool: ???
* MethodMonitoringTool: ???

## RoadRunnerX

* branch contract - new contract tool

## ANaConDA

* analysers/contract-validator
* analysers/param-contract-validator

## RoadRunner + contracts

* input to roadrunner:
  * what are the contracts and what is the API
  * program to be checked

## TODO

* study ant

## Structure

* introduction
* "theory"
  * testing of parallel applications, dynamic vs. static analysis
  * logical clock
  * happens-before
  * contracts for concurrency
  * parametric contracts
  * spoilers
  * dynamic analysis description
  * optimizations
  * trace windows, discarding spoilers and targets
  * vector clocks
  * roadrunner framework
  * instrumentation
  * ASM library
* design
* implementation
* verification
* conclusion

## Implementation

### Advance Instance

always same thread

    started?    in alph?    can adv?    MV match?           FAinst  lastBeg lastEnd begin   started MV
    YES         YES         YES         YES                 adv     -//-    -//-    -//-    -//-    -//-    ideal situation: a(X) b(X)
    YES         YES         YES         NO                  -//-    -//-    -//-    -//-    -//-    -//-    belongs to different instance: a(X) b(Y)
    YES         YES         NO          YES                 -//-    -//-    -//-    -//-    -//-    -//-    instance NOT invalidated - see example below
    YES         YES         NO          NO                  -//-    -//-    -//-    -//-    -//-    -//-    belongs to different instance: a(X) c(Y)
    YES         NO          -           -                   -//-    -//-    -//-    -//-    -//-    -//-    irrelevant: a(X) z(Y)
    NO          YES         YES         -                   -//-    -//-    -//-    -//-    -//-    -//-    start of new instance: a(X)
                                                            adv     -//-    -//-    vc      true    bind    
    NO          YES         NO          -                   -//-    -//-    -//-    -//-    -//-    -//-    not a start: c(X)
    NO          NO          -           -                   -//-    -//-    -//-    -//-    -//-    -//-    irrelevant: z(X)

    target: A(X,Y,Z) B(X,Y) B(Y,Z)
    
    code:
    A(a,b,c) // instance 1 started
    A(b,c,d) // instance 2 started
    B(b,c)   // instance 2 can be advanced, instance 1 is invalidated or not?
