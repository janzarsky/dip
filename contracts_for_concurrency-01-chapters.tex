\chapter{Introduction}

\todo{}

\chapter{Testing and Dynamic Analysis in Java}

\todo{}

\chapter{Contracts for Concurrency}

\todo{chapter contents}

When developing software, one frequently uses modules created by someone else
via it's programming interface. For example, in object oriented programming, the
interface consists of public methods of given class. Accessing the interface
requires one to follow a protocol consisting of: (i) syntax, i.e. types of
parameters and return values, (ii) semantics, i.e. the expected behavior for
given input parameters, and (iii) access restrictions. Access restrictions
include the domain of valid values, dependencies on other services, and
atomicity violations \cite{FITPUB11510}.

\emph{Contracts for concurrency} \cite{FITPUB10817},
\cite{DBLP:journals/corr/SousaDFL15}, are a case of a software protocol that
expresses access restrictions in concurrent setting. In it's basic form, it
specifies sequences of methods that must be executed atomically. The contracts
can be extended with parameters to reflect the data flow between the methods (so
that only methods manipulating the same data must be executed atomically).
Another extension adds so called \emph{spoilers} (so that given sequence must be
executed atomically only with respect to only certain sequences). Both
extensions can be combined \cite{FITPUB11510}.

\section{Basic Contracts}

\emph{Contract} is formally defined in \cite{FITPUB10817} as follows. Let
$\Sigma_\mathbb{M}$ be a set of all public method names (the API) of a module or
a library. A \emph{contract} is a set $\mathbb{R}$ of \emph{clauses}. Each
clause $\varrho \in \mathbb{R}$ is a star-free regular expression over
$\Sigma_\mathbb{M}$. A contract violation occurs when any of the sequences in a
contract is interleaved with an execution of a method from $\Sigma_\mathbb{M}$
over the same object.

\emph{Example.} Consider a map implementation with the following operations:
\texttt{put(key, value)}, \texttt{get(key)}, \texttt{remove(key)}, and
\texttt{contains(key)}. Then a contract for this class may contain the following
clauses: \todo{formatting} \newline
    $(\varrho_1)$ \texttt{put get} \newline
    $(\varrho_2)$ \texttt{contains (put|get|remove)} \newline
Clause $\varrho_1$ states that when an element is put into the map and then
retrieved, it should be executed atomically (because the element may be removed
between the calls). Clause $\varrho_2$ states that when the program modifies the
map based on the result of the \texttt{contains} call, it should be atomic.

\todo{optional: clause composition}

\section{Parametric Contracts}

In some situations, the definition of contracts may be to restrictive, producing
false alarms. In \cite{FITPUB11510}, contracts are extended with parameters to
reflect the data flow between methods. Consider the following example:
\todo{formatting}\newline
\texttt{if (q.contains(42)) q.remove(42);} \newline
These two calls must be executed atomically only if they share the same
argument. This dependency can be expressed using \emph{meta-variables} placed as
the parameters or return values of methods. Parameters that should not be taken
into account are marked with free meta-variable (denoted with underscore).

\emph{Example.} The example from \todo{ref} can be extended with parameters:
\todo{formatting} \newline
    $(\varrho_1)$ \texttt{put(X) \_ = get(X)} \newline
    $(\varrho_2)$ \texttt{\_ = contains(X) ( put(X,\_) | \_ = get(X) | remove(X) )}
    \newline

The basic definition of contracts in fact contains one implicit parameter, the
object that the method was called upon (\texttt{this} in Java)
\cite{FITPUB10817}. To better illustrate this, the example can be rewritten as:
\todo{formatting} \newline
    $(\varrho_1)$ \texttt{X.put(Y) \_ = X.get(Y)} \newline
    $(\varrho_2)$ \texttt{\_ = X.contains(Y) ( X.put(Y,\_) | \_ = X.get(Y) | X.remove(Y) )}

\section{Contracts with Spoilers}

\todo{}

\todo{
  * testing of parallel applications, dynamic vs. static analysis
  * logical clock
  * happens-before
  * dynamic analysis description
  * optimizations
  * trace windows, discarding spoilers and targets
  * vector clocks
  * roadrunner framework
  * instrumentation
  * ASM library
}

\chapter{Dynamic Analyzer for Parametric Contracts}

\todo{}

\chapter{Conclusion}

\todo{}
