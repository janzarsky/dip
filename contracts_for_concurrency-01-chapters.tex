% vim:spelllang=en_us:spell

\chapter{Introduction}

When developing software, one commonly relies on software libraries written by
other developers. To avoid introducing defects into the software, one has to
follow rules laid by the library developer. This includes the syntax of the
library and semantics of operations provided by the library. In concurrent
environment, a new set of problems related to proper synchronization of threads
is introduced.

\emph{Contracts for concurrency} enable library developers to define
restrictions on the library usage in concurrent environment. In its basic form,
it specifies which method sequences must be executed atomically. There are two
extensions for contracts for concurrency. \emph{Parametric contracts} allow to
better identify methods that need to be executed atomically. Contracts with
\emph{spoilers} allow finer control over which thread interleavings breach the
contract. To verify that a program satisfies the restrictions given by contracts
for concurrency, one may use either static or dynamic analysis, both offering
different advantages.

The goal of this project is to design a dynamic analyzer that will be able to
detect contract violations in Java programs. To observe the behavior of the
program under analysis, the program must be modified to report all actions of
interest to the analyzer. That is usually done at the byte code level, and it
requires a lot of skill not to affect the behavior of the program under
analysis. Fortunately, the RoadRunner framework takes care of the instrumenting
and provides a simple interface for observing actions taken by the program under
analysis. The contract analyzer will be built upon the RoadRunner interface.

In order to successfully perform the analysis, the following must be done. A
grammar for contract definitions and a parser must be created. The
instrumentation performed by RoadRunner needs to be extended to extract
additional information about the program under analysis. Then finally, an
analyzer for parametric contracts with spoilers must be implemented using the
RoadRunner interface. This term project deals with the design of the analyzer
and it will be followed by a master's thesis that will focus on implementation
and evaluation of the analyzer.

This report is structured as follows. Chapter \ref{chTwo} describes specifics of
multi-threaded programming in Java, Java memory model, and an overview of
software defects related to concurrency. Approaches to dynamic analysis of Java
programs and instrumentation techniques are described. Two important frameworks
are presented, the ASM framework for byte code instrumentation, and the
RoadRunner framework for writing dynamic analyzers. Chapter \ref{chThree}
introduces contracts for concurrency, their modified versions, and a method for
dynamic detection of contract violations. In Chapter \ref{chFour}, a dynamic
analyzer for contracts is designed.



\chapter{Dynamic Analysis of Multi-threaded Programs in Java}
\label{chTwo}

This chapter starts with necessary basics of multi-threaded programming in Java.
The Java Memory Model is introduced, as it defines important terms such as the
\emph{happens-before} relation or a \emph{data race}. Common defects in
concurrent environment are then described. Section
\ref{approachesToSwVerification} provides overview of approaches to software
verification.

Dynamic analysis of Java programs is then described, starting with an overview
of Java bytecode, and how it can be instrumented using the ASM framework. The
RoadRunner framework for dynamic analysis is then introduced.


\section{Multi-threaded Programming in Java}

Java provides built-in support for multi-threaded programming. This section
describes a typical thread life cycle, synchronization of threads, and
inter-thread communication, as these are important in dynamic analysis using
contracts.

A thread in Java is represented by a \texttt{Thread} object. There are two ways
to create a thread: by extending the \texttt{Thread} class, or by implementing
the \texttt{Runnable} interface. Both approaches produce a \texttt{Thread}
instance which executes the \texttt{run} method in a new thread when started.

To start a thread, the \texttt{start()} method must be called (which will in
turn call the \texttt{run()} method). The thread will terminate upon returning
from the \texttt{run()} method. The \texttt{join()} method is used in other
thread to wait for a thread to terminate \cite{javaTheCompleteReference}.
Figure \ref{threadExtend} shows a thread creation example by extending the
\texttt{Thread} class, Figure \ref{threadRunnable} shows the same example
achieved by implementing the \texttt{Runnable} interface.

\begin{figure}[hbt]
    \label{threadExtend}
\begin{lstlisting}[language=java]
class MyThread extends Thread {
  @Override
  public void run() {
    System.out.println("This is executed in a new thread.");
  }

  public static void main(String args[]) {
    MyThread t = new MyThread();
    t.start();
    t.join();
  }
}
\end{lstlisting}
    \caption{Creating a thread by extending the \texttt{Thread} class.}
\end{figure}

\begin{figure}[hbt]
    \label{threadRunnable}
\begin{lstlisting}[language=java]
class MyRunnable implements Runnable {
  public void run() {
    System.out.println("This is executed in a new thread.");
  }

  public static void main(String args[]) {
    Thread t = new Thread(new MyRunnable());
    t.start();
    t.join();
  }
}
\end{lstlisting}
    \caption{Creating a thread by implementing the \texttt{Runnable} interface.}
\end{figure}

When accessing a shared resource from multiple threads, proper synchronization
is usually required. In Java, every object gets an implicit monitor, which can
be owned by only one thread at a given time. To enter the monitor, one must use
either synchronized methods or synchronized statements. Synchronized statements
are code blocks with explicitly specified object whose monitor is entered before
executing the block. Synchronized methods enter the monitor of the instance they
are called upon. Figure \ref{synchronized} shows examples of synchronized blocks
and synchronized methods.

\begin{figure}[hbt]
    \label{synchronized}
\begin{lstlisting}[language=java]
class Example {
  private int a = 0;

  public synchronized void inc1() {
    a++;
  }

  public void inc2() {
    synchronized (this) {
      a++;
    }
  }
}
\end{lstlisting}
    \caption{The \texttt{inc1} method is \emph{synchronized}, on each call, the
    \texttt{Example} instance's monitor is entered. The \texttt{inc2} method is
    not synchronized, but contains a \emph{synchronized block} with explicitly
    specified monitor.}
\end{figure}

Communication between threads is achieved using the following methods:
\texttt{wait()}, \texttt{notify()}, and \texttt{notifyAll()}. All methods must
be called within a synchronized context. Calling \texttt{wait()} will suspend
the calling thread until some other thread enters the same monitor and calls
either \texttt{notify()} or \texttt{notifyAll()}.

Multi-threaded programs may use the \texttt{volatile} type modifier. It tells
the compiler that the variable may be modified outside of the current thread.

\section{Java Memory Model}

% http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html
% https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5

\emph{Java memory model} describes how threads in Java interact with each other
using shared memory. The model takes a program and an execution trace, and for
each read operation decides, if it is valid or not. The decision depends on the
write operation that modified the data before the read operation. The compiler,
runtime, and hardware must ensure that all executions of a program produce
execution traces that are valid according to the model \cite{jmmspec}.

In a single-threaded program, it is only required that the program produces the
same result as if it was run serially. The compiler is free to reorder
instructions when it does not affect the result of the computation.

In multi-threaded programs, the reordering of instructions has to be limited
when the threads interact with each other. For the purpose of the model, only
certain program \emph{actions} are considered. There are several orders defined
over the actions which are used by the dynamic contract analysis: \emph{program
order}, \emph{synchronization order}, and \emph{happens-before order}.

The actions can be either \emph{intra-} or \emph{inter-thread}. An inter-thread
action can be detected or influenced by another thread. An intra-thread action
is for example adding two local variables and it is not important to the model.
Non-volatile reading or writing of shared variable is an inter-thread action.
\emph{Synchronization actions} are inter-thread actions that include volatile
reading or writing of variables, locking and unlocking of monitors, and starting
and stopping of a thread. Figure \ref{threadActions} shows examples of different
kinds of actions.

\begin{figure}[hbt]
    \label{threadActions}
\begin{lstlisting}[language=java]
class MySharedData {
  int mySharedVar = 0;

  public synchronized void MyMethod() {
    // synchronization action (entering a monitor)
    // intra-thread action (writing a local variable)
    int a = 42;
    // 2 inter-thread actions (reading and writing a shared variable)
    mySharedVar += a;
    // synchronization action (leaving a monitor)
  }
}
\end{lstlisting}
    \caption{Different program actions classified from the Java Memory Model
    point of view. Entering and leaving \texttt{MyMethod} produces
    \emph{synchronization actions}. Accessing \texttt{mySharedVar} is considered
    as an \emph{inter-thread} action, but not as a synchronization action,
    because \texttt{mySharedVar} is not declared as \texttt{volatile}.}
\end{figure}


\emph{Program order} is a total order over all inter-thread actions from a given
thread. It reflects the order in which these actions would be executed if
run by the intra-thread semantics.

\emph{Synchronization order} is a total order over all synchronization actions
of an execution. Within each thread, the synchronization order is consistent
with the program order. The \emph{synchronized-with} relation is defined on
certain actions. \emph{Example}: starting a thread is \emph{synchronized-with}
the first action in the new thread.

\emph{Happens-before order} is a partial order. If an action
\emph{happens-before} another, the first action is visible to and ordered before
the second action. If \emph{x} and \emph{y} belong to the same thread and
\emph{x} comes before \emph{y} in program order, the \emph{x happens-before y}.
If \emph{x synchronizes-with y}, then \emph{x happens-before y}. Figures
\ref{hb1} and \ref{hb2} illustrates the \emph{happens-before} relation in simple
programs.

A \emph{data race} occurs, when there are two accesses to the same variable, at
least one of which is write, and these accesses are not ordered by
\emph{happens-before}. This situation is illustrated in Figure \ref{hb2}.

\begin{figure}[hbt]
    \label{hb1}
    \input{figures/hbexample.tex}
    \caption{\emph{Happens-before} relations in a correctly synchronized program
    consisting of threads $t_1$ and $t_2$. Each arrow represents a
    \emph{happens-before} relation. The red arrows represent the program order,
    the blue arrow represents the \emph{synchronizes-with} relation. Grey arrows
    complete the transitive closure. The conflicting accesses to variable
    \texttt{a} are not a data race, because they are ordered by
    \emph{happens-before} (the black arrow).}
\end{figure}

\begin{figure}[hbt]
    \label{hb2}
    \input{figures/hbexample2.tex}
    \caption{\emph{Happens-before} relations in an incorrectly synchronized
    program (each solid arrow represents a \emph{happens-before} relation).
    There is no \emph{happens-before} relation between conflicting accesses
    \texttt{a=42} and \texttt{print(a)} (the dashed line), creating a data race.}
\end{figure}


\section{Common Defects in Multi-threaded Programs}

\todo{overview}

\subsection{Data Race}

A \emph{data race} occurs when two threads access the same data, at least
one of these accesses is a write, and the threads do not use any mechanism to
prevent the accesses from being simultaneous \cite{eraser}.

\todo{conflict with JMM definition of data race}

\todo{example}

\subsection{Atomicity Violation}

A program that is free from data races may still run into problems caused by
unexpected thread interference. Consider the following example: a code that
first searches an arbitrary data structure to find an element, and then proceeds
to modify the element. Both search and modification operations are synchronized
methods, so there are no data races. But this still allows for another thread to
delete the element between the search and the modification.

The code block that searches and modifies the data structure should be atomic.
Atomicity means that every program execution (regardless of the thread
interleaving) will have the same behavior as if the code block was executed
serially \cite{atomizer}. \todo{}

\todo{example}

\subsection{Order Violation}

\todo{}

\subsection{Other}

\todo{ \newline
* deadlock \newline
* missed signal \newline
* blocked thread, livelock, starvation \newline
}

\section{Approaches to Software Verification}
\label{approachesToSwVerification}

% Carlo Ghezzi, Mehdi Jazayeri, Dino Mandrioli: Fundamentals of Software Engineering, Prentice Hall, ISBN 0-13-099183-X

The goal of software verification is to make sure that the software meets all
requirements. There are two approaches to software verification:
\emph{experimentation} and \emph{analysis}. The experimentation approach
consists of observing the behavior of the software under different conditions,
in other words \emph{testing} the software. Analysis inspects the software to
determine its properties and capabilities. Analysis can be either static or
dynamic. \emph{Dynamic analysis} studies the software while it is running,
\emph{static analysis} is based on static model of the software
\cite{fundamentals}.

\subsection{Testing}

Testing consists of running the software under different conditions and
checking the results of the computation (or observing other behavior of the
software). To gain enough confidence that the software operates correctly in all
conditions, suitable set of \emph{test cases} must be found, which is difficult,
and sometimes impossible. Testing is best suited for confirming presence of
defects in software, not for proving their absence \cite{fundamentals}.

Important property of test cases is their \emph{repeatability}, meaning that a
certain test case will always yield the same result. When testing multi-threaded
programs, this property does not hold because of the non-determinism introduced
by the thread scheduler. Threads are interleaved in a different way on each
execution which means that errors may or may not appear. This makes discovering
defects in multi-threaded programs difficult.

\subsection{Static Analysis}

Static analysis is performed without executing the software.

\todo{}

\subsection{Dynamic Analysis}

\todo{}


\section{Instrumentation of Java Bytecode}

Instrumentation is the act of inserting instructions to an existing program to
extract useful information at runtime. Instrumentation can be used to measure
performance, to log events, or to perform dynamic analysis. The running program
should not be aware that it is being instrumented and the result of the
computation should remain the same.  Instrumentation may add significant
overhead to the program. For example, programs instrumented by the RoadRunner
framework are roughly 10 times slower \cite{RoadRunner}.

In Java, instrumentation is done by changing the bytecode. There are several
general purpose frameworks for modifying the Java bytecode. In this section, the
ASM framework is described as it is used by the RoadRunner framework, which is
the basis of this master's thesis.

\subsection{Java Bytecode Overview}

Programs written in Java are compiled into Java bytecode which is executed by
the Java Virtual Machine. Every class gets compiled into a Java class file
containing the following sections \cite{asmguide}:
\begin{itemize}
    \item Section with information about the class itself, such as the name of
    the class, the super class, implemented interfaces, and class annotations.
    \item One section per field, containing the field name, type, modifiers, and
    annotations.
    \item One section per method (and constructor), containing the name of the
    method, the return type, type of parameters, annotations, and compiled code
    of the method.
\end{itemize}

Java class files also contains a \emph{constant pool} section that holds all
numeric, type, and string constants which are then referenced from other
sections of the file. The whole structure is shown in Table \ref{classfile}.
The Java class file format is described in detail in the Java Virtual Machine
Specification \cite{jvmspec}.

\begin{table}
    \begin{center}
        \label{classfile}
        \begin{tabular}{|l|l|l|}
            \hline
            \multicolumn{2}{|l|}{Modifiers, name, super class, interfaces} \\
            \hline
            \multicolumn{2}{|l|}{Constant pool} \\
            \hline
            \multicolumn{2}{|l|}{Annotations} \\
            \hline
            \multicolumn{2}{|l|}{Attributes} \\
            \hline
            \multirow{3}{*}{Fields} & Modifiers, name, type \\
            & Annotations \\
            & Attributes \\
            \hline
            \multirow{3}{*}{Methods} & Modifiers, name, return and parameter types \\
            & Annotations \\
            & Attributes \\
            & Code \\
            \hline
        \end{tabular}
        \caption{Structure of the Java class file. Adapted from \cite{asmguide},
        simplified.}
    \end{center}
\end{table}

Compiled classes do not contain any \texttt{package} or \texttt{import}
statements, so all type names must be fully qualified. Internally, class files
use slashes instead of dots in type names, so for example
\texttt{java.lang.Object} becomes \texttt{java/lang/Object}. In most places,
Java types are represented with \emph{type descriptors}. Each primitive type is
assigned a single character: \texttt{I} for \texttt{int}, \texttt{D} for
\texttt{Double} and so on. Classes and interfaces are written with prefix
\texttt{L} and semicolon at the end, so string becomes
\texttt{Ljava/lang/String;}. Arrays are represented using a
\texttt{\leftbracket} and the element type, so integer arrays is
\texttt{\leftbracket I}, array of strings is \texttt{\leftbracket
Ljava/lang/String;}. Similarly, \emph{method descriptors} are used to represent
the return type of a method and types of all method parameters. For example, a
method declared as \texttt{double m(int i, String s)} would be represented as
\texttt{(ILjava/lang/String;)D}. In method descriptors, \texttt{V} is used when
the method returns \texttt{void}.

\todo{describe the instructions - groups of instructions, representation,
method invocation, constants}

\subsection{The ASM framework}

The ASM framework allows generating and modifying of Java classes directly in
bytecode. It can be used both statically (for example during compilation) or
dynamically (to create classes at runtime). The ASM framework provides an
interface for loading and storing the bytecode using higher-level abstractions,
such as constants, identifiers, methods, fields, etc. \cite{asmguide}.

There are two interfaces available: the \emph{core API} with an \emph{event
based} representation of classes, and the \emph{tree API} with an \emph{object
based} representation. The core API processes classes sequentially. When parsing
a class, the ASM parser will produce an event for each element of the class.
When writing a class, the writer creates the class based on a sequence of
events. The tree API loads the whole class and creates a tree of objects
representing the class. The core API is faster and requires less memory, however
it is not practical for complex transformations \cite{asmguide}. The RoadRunner
framework uses the core API.

The core API is based on the \texttt{ClassVisitor} abstract class. The class
contains methods for visiting different sections of a class, for example
\texttt{visitAttribute}, \texttt{visitMethod}, or \texttt{visitField}. Complex
sections, such as methods or fields, have their own visitor classes. For
example, the \texttt{MethodVisitor} class contain methods such as
\texttt{visitLocalVariable}, \texttt{visitCode}, or \texttt{visitParameter}
\cite{asmguide}.

To generate a new class, one has to create a \texttt{ClassWriter} instance,
which is a subclass of \texttt{ClassVisitor}. Then a sequence of visit methods
must be called, such as \texttt{visitField} or \texttt{visitMethod}. The
\texttt{ClassWriter} instance will generate appropriate bytecode on each call.

To read and parse a class, one has to create a \texttt{ClassReader} instance.
The reader will produce a sequence of events for each section of the class. To
consume those events, a \texttt{ClassVisitor} instance must be given to the
reader. The reader will then call appropriate visit methods on the visitor as it
is parsing the class. To demonstrate this, one can create a \texttt{ClassReader}
and connect it to a \texttt{ClassWriter} (which is a subclass of
\texttt{ClassVisitor}). The reader will call visit methods on the writer,
effectively copying the class.

\begin{figure}[hbt]
    \input{figures/asm.tex}
    \caption{Typical architecture for class transformation.}
\end{figure}

Typical class transformation uses the following architecture: a
\texttt{ClassReader} instance reads the class, then one or more
\texttt{ClassVisitor} instances modify the class, and then a
\texttt{ClassWriter} instance writes the modified class back to a file.

\section{Dynamic Analysis using RoadRunner}

The RoadRunner framework is used for dynamic analysis of concurrent programs
written in Java. RoadRunner instruments programs to obtain a stream of events
that are useful for dynamic analysis, such as memory accesses, synchronizing on
a lock, forking or joining of threads, and so on. This event stream is then
available to various analysis tools. Multiple tools can be chained together,
each tool acting as a filter over the events. This allows complex analyses to be
built from simpler, modular tools \cite{RoadRunner}.

RoadRunner aims to simplify writing dynamic analysis tools. A RoadRunner
analysis tool only needs to handle events of interest. RoadRunner will ensure
that the event is properly detected and the event handler is called. To store
the state of the analysis, RoadRunner provides support for associating
information with memory locations, locks, or threads.

\todo{tool composition}

\todo{optional: debugging, comparing analyses}

\subsection{The RoadRunner Programming Interface}

Every analyzer in RoadRunner is based on the \texttt{Tool} class. Figure
\ref{toolclass} contains the most important methods of \texttt{Tool}. During the
analysis, every time an action is detected, the appropriate method in
\texttt{Tool} is called, along with an \texttt{Event} object that contains
information about the event.

\begin{figure}[hbt]
    \label{toolclass}
    \caption{\todo{Here will be the most important methods of the Tool class}}
\end{figure}

The following events are detected by the RoadRunner framework:
\begin{itemize}
    \item Method entry and exit.
    \item Memory accesses -- reads and writes to fields and variables.
    \item Lock acquires and releases.
    \item Synchronization signals -- wait and notify.
    \item Thread forking and joining.
\end{itemize}

There are several subclasses of the \texttt{Event} class with specific
information about events.

RoadRunner allows associating information with objects from the program under
analysis. For each thread, a \texttt{ShadowThread} object is created which
contains reference to the underlying thread. Similarly, for each lock, a
\texttt{ShadowLock} object is created. Both extend the \texttt{Decoratable}
class that allows storing of arbitrary information. For associating information
with memory locations, a \emph{shadow location} is created when the location is
first accessed.

Multiple tools can be chained together. Each event handler method forwards the
\texttt{Event} instance to the next tool in chain by default. If the event is
not forwarded, the tool becomes a filter over the event stream. This can be used
to filter out events that are not interesting to a particular analysis and then
performing the analysis in the next tool.

\subsection{Instrumentation Performed by RoadRunner}

RoadRunner uses a modified version of the ASM framework to instrument the
program under analysis.

\todo{how are fields instrumented}

\todo{how are methods instrumented}


\chapter{Contracts for Concurrency}
\label{chThree}

\todo{chapter contents}

When developing software, one frequently uses modules created by someone else
via its programming interface. For example, in object oriented programming, the
interface consists of public methods of given class. Accessing the interface
requires one to follow a protocol consisting of: (i) syntax, i.e. types of
parameters and return values, (ii) semantics, i.e. the expected behavior for
given input parameters, and (iii) access restrictions. Access restrictions
include the domain of valid values, dependencies on other services, and
atomicity violations \cite{FITPUB11510}.

\emph{Contracts for concurrency} \cite{FITPUB10817},
\cite{DBLP:journals/corr/SousaDFL15}, are a case of a software protocol that
expresses access restrictions in concurrent setting. In its basic form, it
specifies sequences of methods that must be executed atomically. The contracts
can be extended with parameters to reflect the data flow between the methods (so
that only methods manipulating the same data must be executed atomically).
Another extension adds so called \emph{spoilers} (so that given sequence must be
executed atomically only with respect to only certain sequences). Both
extensions can be combined \cite{FITPUB11510}.

\section{Basic Contracts}

\emph{Contract} is formally defined in \cite{FITPUB10817} as follows. Let
$\Sigma_\mathbb{M}$ be a set of all public method names (the API) of a module or
a library. A \emph{contract} is a set $\mathbb{R}$ of \emph{clauses}. Each
clause $\varrho \in \mathbb{R}$ is a star-free regular expression over
$\Sigma_\mathbb{M}$. A contract violation occurs when any of the sequences in a
contract is interleaved with an execution of a method from $\Sigma_\mathbb{M}$
over the same object.

\emph{Example.} Consider a map implementation with the following operations:
\texttt{put(key, value)}, \texttt{get(key)}, \texttt{remove(key)}, and
\texttt{contains(key)}. Then a contract for this class may contain the following
clauses: \todo{formatting} \newline
    $(\varrho_1)$ \texttt{put get} \newline
    $(\varrho_2)$ \texttt{contains (put|get|remove)} \newline
Clause $\varrho_1$ states that when an element is put into the map and then
retrieved, it should be executed atomically (because the element may be removed
between the calls). Clause $\varrho_2$ states that when the program modifies the
map based on the result of the \texttt{contains} call, it should be atomic.

\todo{optional: clause composition}


\section{Parametric Contracts}

In some situations, the definition of contracts may be to restrictive, producing
false alarms. In \cite{FITPUB11510}, contracts are extended with parameters to
reflect the data flow between methods. Consider the following example:
\todo{formatting}\newline
\texttt{if (q.contains(42)) q.remove(42);} \newline
These two calls must be executed atomically only if they share the same
argument. This dependency can be expressed using \emph{meta-variables} placed as
the parameters or return values of methods. Parameters that should not be taken
into account are marked with free meta-variable (denoted with underscore).

\emph{Example.} The example from \todo{ref} can be extended with parameters:
\todo{formatting} \newline
    $(\varrho_1)$ \texttt{put(X) \_ = get(X)} \newline
    $(\varrho_2)$ \texttt{\_ = contains(X) ( put(X,\_) | \_ = get(X) | remove(X) )}
    \newline

The basic definition of contracts in fact contains one implicit parameter, the
object that the method was called upon (\texttt{this} in Java)
\cite{FITPUB10817}. To better illustrate this, the example can be rewritten as:
\todo{formatting} \newline
    $(\varrho_1)$ \texttt{X.put(Y) \_ = X.get(Y)} \newline
    $(\varrho_2)$ \texttt{\_ = X.contains(Y) ( X.put(Y,\_) | \_ = X.get(Y) | X.remove(Y) )}


\section{Contracts with Spoilers}

In \cite{FITPUB11510}, contracts are extended with contextual information to
distinguish which method sequences violates the contract. Each clause of the
basic contract is called a \emph{target}, and is assigned a set of so called
\emph{spoilers}. A spoiler is a set of method sequences that may violate its
target.

Consider the clause $\varrho_1$ from example \todo{ref example in Basic
Contracts}. If the element that was put to the map is concurrently removed or
updated before the \texttt{get} call, a contract violation should be detected.
However, calling \texttt{contains} or \texttt{get} on the element will not
affect the computation and should not be marked as a contract violation. In this
example, sequences \texttt{put} and \texttt{remove} are spoilers for a target
 $\varrho_1$, denoted as \texttt{put get} $\leftsquigarrow$
\texttt{put|remove}.

% TODO: this is basically copied - is it ok?

Formally, as defined in \cite{FITPUB11510}, let $\mathbb{R}$ be the set of
\emph{target} clauses where each target $\varrho \in \mathbb{R}$ is a regular
expression over $\Sigma_\mathbb{M}$. Let $\mathbb{S}$ be the set of
\emph{spoilers} where each spoiler $\sigma \in \mathbb{S}$ is a regular
expression over $\Sigma_\mathbb{M}$. A \emph{contract} is a relation $\mathbb{C}
\subseteq \mathbb{R} \times \mathbb{S}$ defining for each target, which spoilers
may cause atomicity violation.

Contract violation is observed when a target sequence $\varrho \in \mathbb{R}$
is fully interleaved by a spoiler sequence $\sigma \in \mathbb{C}(\varrho)$, and
the sequences are executed on the same object.

\emph{Example.} The example from \todo{ref} can be extended with spoilers:
\todo{formatting} \newline
    $(\varrho_1)$ \texttt{put get} $\leftsquigarrow$ \texttt{put|remove} \newline
    $(\varrho_2)$ \texttt{contains (put|get|remove)} $\leftsquigarrow$
    \texttt{put|remove} \newline

\todo{combining spoilers and parameters}


\section{Dynamic Contract Validation}

\todo{section intro}

\subsection{Multi-threaded Program Traces}

For the purposes of dynamic contract validation, multi-threaded program
\emph{trace} consists of events of the following types:
\begin{itemize}
    \item thread forking or joining another thread,
    \item thread entering or exiting a method,
    \item thread acquiring or releasing a lock.
\end{itemize}

All events in a trace are indexed by their position in the trace. Let
$\mathbb{T}$ be a set of threads, $\mathbb{R}$ a set of targets, $\mathbb{S}$ a
set of spoilers, $\mathbb{C} \subseteq \mathbb{R} \times \mathbb{S}$ a set of
contracts, and $\mathbb{L}$ a set of locks. The set of all events that can be
generated by a thread $t \in \mathbb{T}$ is then denoted as $\mathbb{E}_t$. Let
$\mathbb{E} = \bigcup_{t \in \mathbb{T}} \mathbb{E}_t$. A \emph{trace} is then a
sequence $\tau = e_1 \hdots e_n \in \mathbb{E}^+$.

% TODO: basically copied

Given a trace $\tau = e_1 \hdots e_n \in \mathbb{E}^+$, we call its subsequence
$r = e_{i_1} e_{i_2} \hdots e_{i_k}$, $1 < k \leq n$, an \emph{instance} of a
target $\varrho \in \mathbb{R}$ if, and only if:
\begin{itemize}
    \item \todo{}
\end{itemize}

\todo{}

\todo{ \newline
    * trace windows \newline
    * discarding spoilers and targets \newline
    * main algorithm \newline
    * optimizations, vector clocks, happens-before \newline
}



\chapter{Design of a Dynamic Analyzer for Parametric Contracts with Spoilers}
\label{chFour}

This chapter describes the proposed dynamic analyzer for parametric contracts
with spoilers. The analyzer should follow the method for dynamic analysis of
contracts described in \cite{FITPUB11510}. \todo{chapter overview}

The analyzer should be built as a new tool (or a tool chain) for RoadRunner. The
input will be a program under analysis, and a contract definition. The analyzer
will be able to detect contract violations in the program and report them. The
RoadRunner framework will be modified to support obtaining method arguments and
return values. For performance reasons, the RoadRunner framework should also be
modified to instrument only relevant actions of the program under analysis.

\section{Restricting Parametric Contracts}

The analyzer should work with parametric contracts with spoilers (see
\todo{ref}). For \todo{which?} reasons, we decided to limit the usage of
parameters in contracts. It is required that the value of all parameters in
target or spoiler sequences must be determined by the first method in the
sequence. For example, method sequence \texttt{a(X,Y) b(Y,Z)} is illegal,
because after the call to method \texttt{a}, the value of parameter \texttt{Z}
is still unknown. The free meta-variables (\texttt{\_}) do not have to be
determined. For example, the sequence \texttt{a(X,Y) b(\_) c(Y)} is valid. This
restriction enables simple detection of method sequences. \todo{explain why}

The method described in \cite{FITPUB11510} is based on program traces where
every method represents a single event in the trace. However, the RoadRunner
framework produces two events for every method -- method entry and method exit.
Method arguments are available on method entry, the return value is available on
method exit. The analyzer must work around the fact that the return value (which
can be also parameter) is not available at the method entry. Alternatively, the
contracts should be limited to not use parametrized return values.

\section{Contract Representation}

The analyzer takes a contract definition as a parameter. Method names in
contracts must be fully qualified (for example
\texttt{java.lang.Object.toString}). Java allows method overloading, so the
contract definition should allow for distinguishing methods based on the number
and type of their parameters.

\todo{grammar for contract configuration files}

\section{Changes to Instrumentation Performed by RoadRunner}

The RoadRunner framework does not expose the method arguments or the return
value through its API. The \texttt{enter} and \texttt{exit} methods both take a
\texttt{MethodEvent} parameter containing the following information:
\begin{itemize}
    \item Target -- \texttt{null} for static methods, the value of \texttt{this}
        for instance methods.
    \item A \texttt{MethodInfo} object -- static information about the method
        definition (name, descriptor, whether it is synchronized or static).
    \item Call site location -- where was the method invoked.
\end{itemize}

The \texttt{MethodEvent} class should be extended for storing method arguments
and the return value. In RoadRunner, each method call is wrapped in another, so
RoadRunner has access to these values. RoadRunner does not need to provide
argument types, since they are already available in the method descriptor
(stored in \texttt{MethodInfo}). Also, the analysis performs only identity
comparison (in case of objects). Primitive types must be handled correctly and
compared by their value.

For dynamic analysis of contracts for concurrency, only a subset of all events
is required. The RoadRunner framework should be configured or modified to
instrument only the necessary actions of the program under analysis. Event types
that are not used at all, such as memory accesses, should not be instrumented.
Method entries and exits should be instrumented only in case the method is part
of a contract.

\section{A Contract Validator Tool}

The contract analyzer should be implemented as a subclass of the \texttt{Tool}
class. The following methods will be overridden:
\begin{itemize}
    \item \texttt{enter()} and \texttt{exit()}, for detecting spoiler and target
        instances;
    \item \texttt{acquire()} and \texttt{release()}, for detecting
        synchronization between threads;
    \item \texttt{create()}, for creating shadow data for the new thread;
    \item \texttt{preStart()}, for initializing shadow data;
    \item \texttt{postJoin()}, for thread synchronization after joining.
\end{itemize}

Methods for detecting memory accesses will not be used by the analyzer, and also
no data will be stored in shadow memory locations.

For each thread, a \texttt{ShadowThread} object will be created that will store
a \emph{vector clock} for the thread, and information about target and spoiler
instances. For each lock, a \texttt{ShadowLock} object will be created that will
store a vector clock for the lock.

The vector clocks associated with threads and locks will be updated on actions,
that impose a happens-before order of operations between threads. Forking or
joining thread will update both threads' vector clocks. When a thread acquires a
lock, the thread's vector clock is updated. When a lock is released, its vector
clock is updated. The sole purpose of \texttt{acquire()}, \texttt{release()},
\texttt{create()}, \texttt{preStart()}, and \texttt{postJoin()} methods is to
update various vector clocks.

Methods \texttt{enter()} and \texttt{exit()} will track target and spoiler
instances in a thread, and detect contract violations.

\todo{synchronization of the tool itself}

\section{Testability}

In order to properly test the analyzer, its implementation should not rely on
RoadRunner's internal data structures. It should be possible to feed the
analyzer a custom event stream without the need for the RoadRunner framework.



\chapter{Conclusion}

\todo{}
